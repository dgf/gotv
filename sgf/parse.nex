/\(/ {
       if c.GameTree == nil { // root
               c.GameTree = &GameTree{}
               c.Collection = append(c.Collection, c.GameTree)
       } else { // subtree
               s := &GameTree{Parent: c.GameTree}
               c.GameTree.Collection = append(c.GameTree.Collection, s)
               c.GameTree = s
       }
}

/;/ {
       c.Node = &Node{Properties: map[string]string{}}
       c.GameTree.Sequence = append(c.GameTree.Sequence, c.Node)
}

/\)/ {
       c.GameTree = c.GameTree.Parent
}

/[A-Z]+\[(\\\]|[^\]]+)+\]/ < {}
       /[A-Z]+/ {
               c.PropIdent = lex.Text()
       }
       /\[.*/ {
               t := lex.Text()
               t = t[1:len(t) - 1]
               if "C" != c.PropIdent { /* only preserve comments */
                       t = strings.Replace(t, "\n", " ", -1)
               }
               c.Node.Properties[c.PropIdent] = strings.Trim(t, " ")
       }
> {}

//
package sgf
func parse(s string) Collection {
       c := struct {
               Collection
               *GameTree
               *Node
               PropIdent string
       }{}
       lex := NewLexer(strings.NewReader(s))
       NN_FUN(lex)
       return c.Collection
}

